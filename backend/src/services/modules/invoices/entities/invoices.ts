import _ from "lodash";
import { RestTableDefinition } from "../../../../platform/db/api";
import {
  classToSchema,
  columnsFromEntity,
  schemaFromEntity,
} from "../../../../platform/schemas/utils";
import {
  Address,
  InvoiceFormat,
  InvoiceSubscription,
  Payment,
} from "../../../clients/entities/clients";
import {
  RestEntity,
  RestEntityColumnsDefinition,
} from "../../../rest/entities/entity";
import { flattenKeys } from "../../../utils";

export default class Invoices extends RestEntity {
  assigned = ["type:users"];
  type:
    | "quotes"
    | "invoices"
    | "credit_notes"
    | "supplier_quotes"
    | "supplier_invoices"
    | "supplier_credit_notes" = "invoices"; // invoices, quotes, credit_notes

  // Quotes: “draft”, “sent”, "purchase_order", "completed", "closed”
  // Invoices and Credit Notes: “draft”, "sent", "closed"
  state:
    | "draft"
    | "sent"
    | "purchase_order"
    | "recurring"
    | "completed"
    | "closed" = "draft";

  // For credit notes or supplier credit note: invoices refunded by this credit note
  from_rel_invoice = ["type:invoices"]; // Nullable
  // For invoices or supplier invoice: quotes completed and transformed into this invoice
  from_rel_quote = ["type:invoices"]; // Nullable

  name = "string";
  reference = "string";
  alt_reference = "string";
  reference_preferred_value = 0; // If > 0 it well be used for the reference

  supplier = "type:contacts"; // For supplier invoices/quotes/credit_notes
  client = "type:contacts"; // For client invoices/quotes/credit_notes
  contact = "type:contacts"; // Nullable, the person in the client we discuss with

  emit_date = new Date();
  wait_for_completion_since = new Date(); // For completed quotes or invoices
  language = "string";
  currency = "string";

  delivery_address = new Address();
  delivery_date = new Date();
  delivery_delay = 30; // In days

  content = [new InvoiceLine()];
  discount = new InvoiceDiscount();

  // This is automatically generated from the content
  total = new InvoiceTotal(); // Precomputed values (for search mainly, do not use for calculations preferably)
  articles = {
    all: ["type:articles"], // List of all articles mentioned in the invoice
    accepted: ["type:articles"], // List of articles accepted by the client (in case of options)
    computed_tags: ["type:tags"], // Automatically generated from the content
  }; // Automatically generated from the content

  // For partially paid invoices or credit notes, list of payments
  transactions = new PaymentComputed();
  // For partially invoiced quotes, list of invoices (or credit notes)
  invoiced = new InvoicedComputed();

  payment_information = new Payment();
  format = new InvoiceFormat();

  recipients = [new Recipient()];

  reminders = new InvoiceReminder();
  next_reminder = new Date(); // Automatically generated from the content
  reminder_count = 0; // Automatically generated from the content

  subscription = new InvoiceSubscription(); // Available only for quotes
  from_subscription?: FromSubscription = new FromSubscription(); // Available only for invoices
  has_subscription = false; // Automatically generated from the content
  subscription_next_invoice_date?: Date = new Date(); // Automatically generated by the backend
  subscription_started_at?: Date = new Date(); // Automatically generated from the content
  subscription_ends_at?: Date = new Date(); // Automatically generated from the content

  attachments = ["type:files"]; // Visible by the client

  notes = "string";
  documents = ["type:files"]; // Internal documents linked to the invoice
  tags = ["type:tags"];

  cache = {
    partner_names: "",
    from_rel_quote_ref: "",
  };
}

export class FromSubscription {
  // When invoice was generated from a subscription, details goes there
  frequency: "daily" | "weekly" | "monthly" | "yearly" | string = "monthly";
  from = new Date(); // Invoiced period start
  to = new Date(); // Invoiced period end
}

export class PaymentComputed {
  percentage = 0; // Between 0 and 100
  total = 0; // This one is automatically generated from the transactions
  ids = ["type:accounting_transactions"]; // List of payments executed automatically generated from trigger
}

export class Recipient {
  email = "string";
  role: "signer" | "viewer" = "signer";
}

export class InvoicedComputed {
  percentage = 0; // Between 0 and 100
  percentage_with_draft = 0; // Between 0 and 100
  ids = ["type:invoices"]; // List of invoices automatically generated from trigger
}

export class InvoicePaymentExecuted {
  date = new Date();
  mode: Payment["mode"] = ["bank_transfer"];
  reference = "string";
  amount = 0;
  notes = "string";
}

export class InvoiceTotal {
  initial = 0;
  discount = 0;
  total = 0;
  taxes = 0;
  total_with_taxes = 0;
}

export class InvoiceReminder {
  enabled = false;
  repetition = 0; // Number of weeks of repetitions
}

export class InvoiceLine {
  article = "type:articles"; // Nullable

  type: "product" | "service" | "consumable" | "separation" | "correction" =
    "product"; // product, service, consumable, separation
  name = "string";
  reference = "string";
  description = "string";

  unit = "string";
  quantity = 0;
  unit_price = 0;
  tva = "string";
  discount = new InvoiceDiscount();

  subscription: "" | "daily" | "monthly" | "yearly" | "weekly" | string = ""; // Can be 3_yearly, 6_monthly etc

  // Only for quotes and supplier quotes
  quantity_ready = 0; //Quantity received or sent to determine if the line is ready to be "completed"
  quantity_delivered = 0; //Quantity received or sent to determine if the line is ready to be duplicated as "invoices"
  // Automatically maintained up to date from the stock_items.rel_quote, cannot be changed from invoice

  optional = false;
  optional_checked = false; // Checked by the client or by the agent (like a default checked option)
}

export class InvoiceDiscount {
  mode: "percentage" | "amount" | null = "amount"; // "percentage" | "amount"
  value = 0;
}

export const InvoicesDefinition: RestTableDefinition = {
  name: "invoices",
  columns: {
    ...columnsFromEntity(Invoices),
    ...new RestEntityColumnsDefinition(),
    notes: "TEXT",
    state_order:
      "BIGINT GENERATED ALWAYS AS (CASE state WHEN 'draft' THEN 1 WHEN 'sent' THEN 2 WHEN 'purchase_order' THEN 3 WHEN 'recurring' THEN 4 WHEN 'completed' THEN 5 WHEN 'closed' THEN 6 ELSE 0 END) STORED",
  },
  pk: ["client_id", "id"],
  indexes: [
    "USING GIST (client_id, state, emit_date)",
    "USING GIN (searchable_generated)",
  ],
  auditable: true,
  rest: {
    label: (entity: Invoices) =>
      [entity?.reference, entity?.name].filter(Boolean).join(" - "),
    searchable: (entity: Invoices) => {
      return [
        Object.values(
          flattenKeys(_.pick(entity, ["name", "reference", "alt_reference"]))
        ).join(" "),
        entity.cache?.partner_names || "",
        entity.cache?.from_rel_quote_ref || "",
      ].join(" ");
    },
    schema: classToSchema(new Invoices()),
  },
};

export const InvoicesSchema = schemaFromEntity<Invoices>(
  InvoicesDefinition.columns
);
